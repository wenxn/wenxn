<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="linux," />










<meta name="description" content="1.监控系统服务器的状态–&amp;gt;常用的性能指标CPU：平均负载(Load Average)这个指标便能很好得对其进行表征命令有uptime，显示服务器已运行时间和最近1分钟，5分钟，15分钟的系统平均负载top，显示进程消息，看cpu负载情况   内存：内存监控一般包括total(机器总内存)、free(机器可用内存)、swap(交换区大小)、cache(缓存大小)等。命令有：vmstat（物理">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="IO">
<meta property="og:url" content="http://yoursite.com/2018/10/06/linux/index.html">
<meta property="og:site_name" content="wen">
<meta property="og:description" content="1.监控系统服务器的状态–&amp;gt;常用的性能指标CPU：平均负载(Load Average)这个指标便能很好得对其进行表征命令有uptime，显示服务器已运行时间和最近1分钟，5分钟，15分钟的系统平均负载top，显示进程消息，看cpu负载情况   内存：内存监控一般包括total(机器总内存)、free(机器可用内存)、swap(交换区大小)、cache(缓存大小)等。命令有：vmstat（物理">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-06T12:59:24.748Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IO">
<meta name="twitter:description" content="1.监控系统服务器的状态–&amp;gt;常用的性能指标CPU：平均负载(Load Average)这个指标便能很好得对其进行表征命令有uptime，显示服务器已运行时间和最近1分钟，5分钟，15分钟的系统平均负载top，显示进程消息，看cpu负载情况   内存：内存监控一般包括total(机器总内存)、free(机器可用内存)、swap(交换区大小)、cache(缓存大小)等。命令有：vmstat（物理">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/06/linux/"/>





  <title>IO | wen</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/06/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="烟华。">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my_photo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IO</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-06T00:00:00+08:00">
                2018-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>1.监控系统服务器的状态<br>–&gt;常用的性能指标<br>CPU：平均负载(Load Average)这个指标便能很好得对其进行表征<br>命令有<br>uptime，显示服务器已运行时间和最近1分钟，5分钟，15分钟的系统平均负载<br>top，显示进程消息，看cpu负载情况  </p>
<p>内存：内存监控一般包括total(机器总内存)、free(机器可用内存)、swap(交换区大小)、cache(缓存大小)等。<br>命令有：<br>vmstat（物理内存状态），会列出相应的内存指标大小，也有cpu，io情况<br>free，显示的直接是内存信息<br>cat /proc/meminfo 也可以通过查看此文件<br>–》拓展一下，可能问buffer与cache的区别  </p>
<p>磁盘：内核希望能尽可能产生次缺页中断（从文件缓存区读），并且能尽可能避免主缺页中断（从硬盘读）<br>命令有：<br>vmstat 有相应的io信息<br>iostat 有写入与读取的block数和速率<br>sar -d 关于磁盘的报告，其中%util：表示一秒中有百分之几的时间用于I/O操作  </p>
<p>网络io：如果服务器网络连接过多，那么会造成大量的数据包在缓冲区长时间得不到处理，一旦缓冲区不足，便会造成数据包丢失问题<br>命令有：<br>netstat -luntp 查看监听的端口<br>相关参数：<br>-a或–all   显示所有连线中的Socket。<br>  -c或–continuous   持续列出网络状态。<br>  -C或–cache   显示路由器配置的快取信息。<br>  -e或–extend   显示网络其他相关信息。<br>  -F或–fib   显示FIB。<br>  -g或–groups   显示多重广播功能群组组员名单。<br>  -h或–help   在线帮助。<br>  -i或–interfaces   显示网络界面信息表单。<br>  -l或–listening   显示监控中的服务器的Socket。<br>  -M或–masquerade   显示伪装的网络连线。<br>  -n或–numeric   直接使用IP地址，而不通过域名服务器。<br>  -N或–netlink或–symbolic   显示网络硬件外围设备的符号连接名称。<br>  -o或–timers   显示计时器。<br>  -p或–programs   显示正在使用Socket的程序识别码和程序名称。<br>  -r或–route   显示Routing Table。<br>  -s或–statistice   显示网络工作信息统计表。<br>  -t或–tcp   显示TCP传输协议的连线状况。<br>  -u或–udp   显示UDP传输协议的连线状况。<br>  -v或–verbose   显示指令执行过程。<br>  -V或–version   显示版本信息。<br>  -w或–raw   显示RAW传输协议的连线状况。<br>  -x或–unix   此参数的效果和指定”-A unix”参数相同。<br>  –ip或–inet   此参数的效果和指定”-A inet”参数相同。<br> –》查看web服务器的连接数（负载均衡）<br>netstat -na | sed -n ‘3,$p’ |awk ‘{print $5}’ | grep -v 127.0.0.1 | grep -v 0.0.0.0 | wc -l   </p>
<p>2.LVS，Nginx负载均衡<br>–LVS四种模式，原理，区别，十种算法<br>四种模式：NAT（地址转换）、DR（直接路由）、TUN（隧道），full-nat（全地址转换）  </p>
<p>原理：工作在网络层（有点像iptables）  </p>
<ol>
<li>当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间   </li>
<li>PREROUTING链首先会接收到用户请求，判断目标IP确定是本机IP，将数据包发往INPUT链   </li>
<li>IPVS是工作在INPUT链上的，当用户请求到达INPUT时，IPVS会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时IPVS会强行修改数据包里的目标IP地址及端口，并将新的数据包发往POSTROUTING链   </li>
<li>POSTROUTING链接收数据包后发现目标IP地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器   </li>
</ol>
<p>区别<br>1.nat模式修改数据包的目标IP地址为后端服务器IP<br>2.dr模式将请求报文中的源MAC地址修改为DIP的MAC地址<br>3.tun模式在原有的IP报文外再次封装多一层IP首部   </p>
<p>八种算法<br>固定调度算法：rr，wrr，dh，sh<br>动态调度算法：wlc，lc，lblc，lblcr<br>1.轮叫调度 rr<br>这种算法是最简单的，就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是简单。轮询算法假设所有的服务器处理请求的能力都是一样的，调度器会将所有的请求平均分配给每个真实服务器，不管后端 RS 配置和处理能力，非常均衡地分发下去。   </p>
<ol start="2">
<li>加权轮叫 wrr<br>这种算法比 rr 的算法多了一个权重的概念，可以给 RS 设置权重，权重越高，那么分发的请求数越多，权重的取值范围 0 – 100。主要是对rr算法的一种优化和补充， LVS 会考虑每台服务器的性能，并给每台服务器添加要给权值，如果服务器A的权值为1，服务器B的权值为2，则调度到服务器B的请求会是服务器A的2倍。权值越高的服务器，处理的请求越多。   </li>
<li>最少链接 lc<br>这个算法会根据后端 RS 的连接数来决定把请求分发给谁，比如 RS1 连接数比 RS2 连接数少，那么请求就优先发给 RS1   </li>
<li>加权最少链接 wlc 这个算法比 lc 多了一个权重的概念。     </li>
<li>基于局部性的最少连接调度算法 lblc<br>这个算法是请求数据包的目标 IP 地址的一种调度算法，该算法先根据请求的目标 IP 地址寻找最近的该目标 IP 地址所有使用的服务器，如果这台服务器依然可用，并且有能力处理该请求，调度器会尽量选择相同的服务器，否则会继续选择其它可行的服务器   </li>
<li>复杂的基于局部性最少的连接算法 lblcr<br>记录的不是要给目标 IP 与一台服务器之间的连接记录，它会维护一个目标 IP 到一组服务器之间的映射关系，防止单点服务器负载过高。   </li>
<li>目标地址散列调度算法 dh<br>该算法是根据目标 IP 地址通过散列函数将目标 IP 与服务器建立映射关系，出现服务器不可用或负载过高的情况下，发往该目标 IP 的请求会固定发给该服务器。   </li>
<li>源地址散列调度算法 sh<br>与目标地址散列调度算法类似，但它是根据源地址散列算法进行静态分配固定的服务器资源。   </li>
</ol>
<p>–&gt;lvs一般是和keepalived一起组合使用的。在keepalived中调用  lvs：<br>假设有两台负载均衡器，做HA高可用集群(lvs+keepalived)<br>要先在两台机器上打开ip_forward转发功能 echo “1” &gt; /proc/sys/net/ipv4/ip_forward<br>都要在keepalived.conf配置vrrp版块（优先级，配置id，网卡，角色）和多台rs的VIP信息等等，启动服务，主从共享VIP资源     </p>
<p>–Nginx负载均衡原理和它的配置文件<br>负载均衡原理<br>nginx扮演了反向代理服务器的角色，它的upstream负载均衡模块，目前支持的分配算法：<br>1)、轮询 。1：1 轮流处理请求（默认），每个请求按时间顺序逐一分配到不同的应用服务器，如果应用服务器down掉，自动剔除，剩下的继续轮询。<br>2)、权重 。通过配置权重，指定轮询几率，权重和访问比率成正比，用于应用服务器性能不均的情况。<br>3)、ip_哈希算法。每个请求按访问ip的hash结果分配，这样每个访客固定访问一个应用服务器，可以解决session共享的问题。   </p>
<p>nginx配置文件：<br>1.全局配置<br>=运行用户<br>=启动进程数（通常设置成和cpu的数量相等）<br>=全局错误日志及PID文件<br>=event模块：工作模式及连接数上限（epoll）等  </p>
<p>2.http服务器配置<br>=全局（日志格式，连接超时时间，gzip压缩，引用其他配置文件）<br>=upstream模块，设置负载均衡，如</p>
<pre><code>upstream mysvr {
#weigth参数表示权值，权值越高被分配到的几率越大
#本机上的Squid开启3128端口
server 192.168.8.1:3128 weight=5;
server 192.168.8.2:80  weight=1;
server 192.168.8.3:80  weight=6;
}
</code></pre><p>=server模块，配置虚拟服务器主机<br>location表示url地址匹配<br>root 根目录即访问路径<br>proxy_pass  地址，所有请求都会先通过nginx反向代理服务器<br>rewrite  regex replacement flag（url重定向规则）  </p>
<p> –&gt;Nginx的Rewrite规则编写实例(举例，下厨房手撕代码有涉及）</p>
<pre><code>1.当访问的文件和目录不存在时，重定向到某个php文件
　　　　if ( !-e $request_filename )
　　　　{
　　　　　　rewrite ^/(.*)$ index.php last;
　　　　}

   2.文件和目录不存在的时候重定向：
　　if (!-e $request_filename)
　　 {
　　　　proxy_pass http://127.0.0.1;
　　}

　　3.如果客户端使用的是IE浏览器，则重定向到/ie目录下
　　　　if( $http_user_agent ~ MSIE)
　　　　{
　　　　　　rewrite ^(.*)$ /ie/$1 break;
　　　　}

　　4.禁止访问以/data开头的文件
　　　　location ~ ^/data
　　　　{
　　　　　　deny all;
　　　　}

　　5.禁止访问以.sh,.flv,.mp3为文件后缀名的文件
　　　　location ~ .*\.(sh|flv|mp3)$
　　　　{
　　　　　　return 403;
　　　　}

　　6.设置某些类型文件的浏览器缓存时间
　　　　location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
　　　　{
　　　　　　expires 30d;
　　　　}
　　　　location ~ .*\.(js|css)$
　　　　{
　　　　　　expires 1h;
　　　　}


7.只允许固定ip访问网站，并加上密码
　　root /opt/htdocs/www;
　　allow 208.97.167.194; 
　　allow 222.33.1.2; 
　　allow 231.152.49.4;
　　deny all;
　　auth_basic “C1G_ADMIN”;
　　auth_basic_user_file htpasswd;

8.域名跳转
　　server
　　{
　　　　listen 80;
　　　　server_name jump.linuxidc.com;
　　　　index index.html index.htm index.php;
　　　　root /opt/lampp/htdocs/www;
　　　　rewrite ^/ http://www.linuxidc.com/;
　　　　access_log off;
　　}

9.多域名转向
　　server_name www.linuxidc.com www.linuxidc.net;
　　index index.html index.htm index.php;
　　root /opt/lampp/htdocs;
　　if ($host ~ &quot;linuxidc\.net&quot;) {
　　　　rewrite ^(.*) http://www.linuxidc.com$1permanent;
　　}
</code></pre><p>–Nginx与LVS区别</p>
<p>LVS是一个可以工作在网络第四层的负载均衡软件，因此它相对于Nginx一类工作在第七层的负载均衡软件有着无可比拟的性能优势。lvs一般很少出现故障，抗负载能力强。lvs仅分发请求，无流量。<br>nginx工作在网络的第7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，对网络的依赖较小。可做小型的web服务器，可重写url地址，支持高并发连接，且配置文件非常简单，节省带宽：支持gzip压缩，内置的健康检查功能  </p>
<p>–Nginx与Apache区别<br>nginx优点：<br>轻量级，同样起web 服务，比apache 占用更少的内存及资源<br>抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能<br>高度模块化的设计，编写模块相对简单<br>社区活跃，各种高性能模块出品迅速啊   </p>
<p>apache优点：<br>rewrite ，比nginx 的rewrite 强大<br>模块多<br>少bug ，nginx 的bug 相对较多<br>超稳定  </p>
<p>3.linux命令<br>–查看远端端口的命令<br>一：telnet ​此法常被用来检测是个远端端口是否通畅。<br>例：telnet baidu.com 80<br>二：通过nmap来检查端口是否通畅<br>例：nmap etiantian.org -p 80<br>三：通过nc命令检查<br>例：nc -w 5  211.100.98.99 80    </p>
<p>–软链接与硬链接<br>–&gt;在 Linux 系统中查看 inode 号可使用命令 stat 或 ls -i<br>硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：<br>文件有相同的 inode 及 data block；<br>只能对已存在的文件进行创建；<br>不能交叉文件系统进行硬链接的创建；<br>不能对目录进行创建，只可对文件创建；<br>删除一个硬链接文件并不影响其他有相同 inode 号的文件。<br>当 Linux 挂载多个文件系统后将出现 inode 号重复的现象，因此硬链接创建时不可跨文件系统。  </p>
<p>软链接就是一个普通文件，文件用户数据块中存放的内容是另一文件的路径名的指向。软链接有着自己的 inode 号以及用户数据块，因此软链接的创建与使用没有类似硬链接的诸多限制：<br>软链接有自己的文件属性及权限等；<br>可对不存在的文件或目录创建软链接；<br>软链接可交叉文件系统；<br>软链接可对文件或目录创建；<br>创建软链接时，链接计数 i_nlink 不会增加；<br>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。  </p>
<p>–使用命令显示某个目录下的所有文件—— ls  </p>
<p>4.shell脚本<br>–统计日志文件中ip出现的次数（ip在第一列）<br>cat test.txt|awk ‘{print $1}’|sort|uniq -c #sort -k可指定根据哪一行排序<br>–一个文本文件，找出前10个经常出现的词<br>1.直接排序法<br>使用cat file|format key|sort | uniq -c | sort -nr | head -n 10 ，占用内存比较多  </p>
<p>2.Hash Table法 (这种方法统计字符串出现的次数非常好)<br>维护一个Key为Query字串，Value为该Query出现次数的 HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。  </p>
<p>然后维护一个K(该题目中是10)大小的小根堆，然后遍历300万的数据，分别和根元素进行对比。<br>原理：<br>a、如果小根堆没有满，就直接将(str,times)加入堆，然后进行建堆调整(heapInsert调整)，堆中Node类实例之间都以词频(times)来进行比较，词频越小，位置越往上。<br> b、如果小根堆已满，说明此时小根堆已经选出k个最高词频的字符串，那么整个小根堆的堆顶自然代表已经选出的k个最高词频的字符串中，词频最低的那个。堆顶的元素记为(headStr,minTimes)。如果minTimes小于times,说明字符串str有资格进入当前k个最高词频字符串的范围。而headStr应该被移出这个范围，所以把当前的堆顶(headStr,minTimes)替换成(str,times),然后从堆顶的位置进行堆的调整(heapify),如果minTimes&gt;=times，说明字符串str没有资格进入当前k个最高词频字符串的范围，因为str的词频还不如目前选出的k个最高词频字符串中词频最少的那个，所以说明也不做。<br>c、遍历完strArr之后，小根堆里就是所有字符串中k个最高词频的字符串</p>
<p>插入小根堆数据：  </p>
<p>–把a.txt文件中的字符A全部替换成字符B<br>sed  -i  “s/A/B/g”  a.txt  </p>
<p>–如果日志里面出现error 或者warning 抓取关键字放到一个新文件，用什么命令<br>grep {error | warning} a.log &gt;&gt; log.txt<br>-v 反向查找  </p>
<p>5.架构<br>–高可用web架构<br>1.nginx反向代理服务器解决单点故障，实现负载均衡   </p>
<ol start="2">
<li>使用keepalived对Nginx缓存服务进行高可用故障转移和灾难恢复<br>3.后端web集群，可用nginx做web服务器<br>4.配置MySQL主主同步之高可用，主从同步<br>5.memcached1缓存MySQLmaster，使用memcached实现session共享<br>6.zabbix监控  </li>
</ol>
<p>6.磁盘阵列<br>–介绍<br>网络存储的服务器中硬盘的连接模式，独立冗余磁盘阵列  </p>
<p>–分类及优缺点<br> 1、RAID0模式<br>优点：在RAID 0状态下，存储数据被分割成两部分，分别存储在两块硬盘上，此时移动硬盘的理论存储速度是单块硬盘的2倍，实际容量等于两块硬盘中较小一块硬盘的容量的2倍。<br>缺点：任何一块硬盘发生故障，整个RAID上的数据将不可恢复。  </p>
<p>2、RAID1模式<br>优点：此模式下，两块硬盘互为镜像。当一个硬盘受损时，换上一块全新硬盘(大于或等于原硬盘容量)替代原硬盘即可自动恢复资料和继续使用，移动硬盘的实际容量等于较小一块硬盘的容量，存储速度与单块硬盘相同。RAID 1的优势在于任何一块硬盘出现故障是，所存储的数据都不会丢失。<br>缺点：该模式可使用的硬盘实际容量比较小，仅仅为两颗硬盘中最小硬盘的容量。  </p>
<p>3、RAID 0+1模式<br>RAID 0+1是磁盘分段及镜像的结合，采用2组RAID0的磁盘阵列互为镜像，它们之间又成为一个RAID1的阵列。硬盘使用率只有50%，磁盘使用率低，但是提供最佳的速度及可靠度。  </p>
<p>4、RAID 5模式<br>最少3块磁盘<br>数据条带形式分布<br>以奇偶校验作冗余<br>适合多读少写的情景，是性能与数据冗余最佳的折中方案<br>RAID5不对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。  </p>
<p>5、RAID 10模式<br>最少需要4块磁盘<br>先按RAID 0分成两组，再分别对两组按RAID 1方式镜像<br>兼顾冗余(提供镜像存储)和性能(数据条带形分布)<br>在实际应用中较为常用<br>RAID10最少需要4块硬盘才能完成。把2块硬盘组成一个RAID1，然后两组RAID1组成一个RAID0。虽然RAID10方案造成了50%的磁盘浪费，但是它提供了200%的速度和单磁盘损坏的数据安全性。  </p>
<p>7.SSH<br>–解释<br>SSH是一种网络协议，用于计算机之间的加密登录。SSH的默认端口是22<br>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：<br>（1）远程主机收到用户的登录请求，把自己的公钥发给用户。<br>（2）用户使用这个公钥，将登录密码加密后，发送回来。<br>（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。  </p>
<p>–登录原理<br>常用的登录验证方式有密码口令登录和公钥登录，两者的原理类似。假设用户以下方式远程登录:   </p>
<pre><code>&gt; # 密码登录$ ssh user@host  
&gt; # 公钥登录$ ssh -i /path/to/public.pem user@host  
</code></pre><p>所谓”公钥登录”，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：<br>    　　$ ssh-keygen</p>
<p>8.linux的启动过程  </p>
<p>　　启动第一步–加载BIOS<br>　　启动第二步–读取MBR<br>　　启动第三步–Boot Loader<br>　　启动第四步–加载内核<br>　　启动第五步–用户层init依据inittab文件来设定运行等级<br>　　启动第六步–init进程执行rc.sysinit<br>　　启动第七步–启动内核模块<br>　　启动第八步–执行不同运行级别的脚本程序<br>　　启动第九步–执行/etc/rc.d/rc.local<br>　　启动第十步–执行/bin/login程序，进入登录状态  </p>
<p>9.linux中二进制文件的编译过程<br>–分类<br>基本上将高级语言分为两大类，一种是编译型语言，例如C，C++，Java，另一种是解释型语言，例如Python、Ruby、MATLAB 、JavaScript。<br>–主要步骤<br>高层的C/C++语言编写的程序转换成为处理器能够执行的二进制代码的过程，包括四个步骤：<br>预处理（Preprocessing）<br>编译（Compilation）<br>汇编（Assembly）<br>链接（Linking）  </p>
<p>–Linux编译器<br>GCC是GUN Compiler Collection的简称，是Linux系统上常用的编译工具。GCC工具链软件包括GCC、Binutils、C运行库等。  </p>
<p>–演示过程<br>先准备一个C语言编写的简单Hello程序作为示例，其源代码如下所示：</p>
<pre><code>#include &lt;stdio.h&gt; 
int main(void)
{
  printf(&quot;Hello World! \n&quot;);
  return 0;
}
</code></pre><p>–编译过程<br>1.预处理<br>预处理的过程主要包括以下过程：<br>将所有的#define删除，并且展开所有的宏定义，并且处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等。<br>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。<br>删除所有注释“//”和“/<em> </em>/”。<br>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。<br>保留所有的#pragma编译器指令，后续编译过程需要使用它们。  </p>
<p>使用gcc进行预处理的命令如下：  </p>
<pre><code>$ gcc -E hello.c -o hello.i // 将源文件hello.c文件预处理生成hello.i
// GCC的选项-E使GCC在进行完预处理后即停止
</code></pre><p>2.编译<br>编译过程就是对预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。  </p>
<p>使用gcc进行编译的命令如下：  </p>
<pre><code>$ gcc -S hello.i -o hello.s // 将预处理生成的hello.i文件编译生成汇编程序hello.s
// GCC的选项-S使GCC在执行完编译后停止，生成汇编程序
</code></pre><p>3.汇编<br>汇编过程调用对汇编代码进行处理，生成处理器能识别的指令，保存在后缀为.o的目标文件中。由于每一个汇编语句几乎都对应一条处理器指令，因此，汇编相对于编译过程比较简单，通过调用Binutils中的汇编器as根据汇编指令和处理器指令的对照表一一翻译即可。  </p>
<p>当程序由多个源代码文件构成时，每个文件都要先完成汇编工作，生成.o目标文件后，才能进入下一步的链接工作。注意：目标文件已经是最终程序的某一部分了，但是在链接之前还不能执行。  </p>
<p>使用gcc进行汇编的命令如下：  </p>
<pre><code>$ gcc -c hello.s -o hello.o // 将编译生成的hello.s文件汇编生成目标文件hello.o
// GCC的选项-c使GCC在执行完汇编后停止，生成目标文件
//或者直接调用as进行汇编
$ as -c hello.s -o hello.o //使用Binutils中的as将hello.s文件汇编生成目标文件
</code></pre><p>注意：hello.o目标文件为ELF（Executable and Linkable Format）格式的可重定向文件。  </p>
<p>4.链接<br>链接也分为静态链接和动态链接，其要点如下：<br>静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。链接器将函数的代码从其所在地（不同的目标文件或静态链接库中）拷贝到最终的可执行程序中。为创建可执行文件，链接器必须要完成的主要任务是：符号解析（把目标文件中符号的定义和引用联系起来）和重定位（把符号定义和内存地址对应起来然后修改所有对符号的引用）。<br>动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。<br>在Linux系统中，gcc编译链接时的动态库搜索路径的顺序通常为：首先从gcc命令的参数-L指定的路径寻找；再从环境变量LIBRARY_PATH指定的路径寻址；再从默认路径/lib、/usr/lib、/usr/local/lib寻找。<br>在Linux系统中，执行二进制文件时的动态库搜索路径的顺序通常为：首先搜索编译目标代码时指定的动态库搜索路径；再从环境变量LD_LIBRARY_PATH指定的路径寻址；再从配置文件/etc/ld.so.conf中指定的动态库搜索路径；再从默认路径/lib、/usr/lib寻找。<br>在Linux系统中，可以用ldd命令查看一个可执行程序依赖的共享库。    </p>
<p>由于链接动态库和静态库的路径可能有重合，所以如果在路径中有同名的静态库文件和动态库文件，比如libtest.a和libtest.so，gcc链接时默认优先选择动态库，会链接libtest.so，如果要让gcc选择链接libtest.a则可以指定gcc选项-static，该选项会强制使用静态库进行链接。  </p>
<p>–以Hello World为例：<br>如果使用命令“gcc hello.c -o hello”则会使用动态库进行链接，生成的ELF可执行文件的大小（使用Binutils的size命令查看）和链接的动态库（使用Binutils的ldd命令查看）如下所示：  </p>
<pre><code>$ gcc hello.c -o hello  
$ size hello  //使用size查看大小  
   textdata bss dec hex filename
   1183 552   81743 6cf hello
$ ldd hello //可以看出该可执行文件链接了很多其他动态库，主要是Linux的glibc动态库
</code></pre><p>如果使用命令“gcc -static hello.c -o hello”则会使用静态库进行链接，生成的ELF可执行文件的大小（使用Binutils的size命令查看）和链接的动态库（使用Binutils的ldd命令查看）如下所示：  </p>
<pre><code>$ gcc -static hello.c -o hello
$ size hello //使用size查看大小
 text data bss dec hex filename
 8237 2672846360  837370   cc6fa hello //可以看出text的代码尺寸变得极大
$ ldd hello
   not a dynamic executable //说明没有链接动态库
</code></pre><p>链接器链接后生成的最终文件为ELF格式可执行文件，一个ELF可执行文件通常被链接为不同的段，常见的段譬如.text、.data、.rodata、.bss等段。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux/" rel="tag"># linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/06/docker/" rel="next" title="docker">
                <i class="fa fa-chevron-left"></i> docker
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my_photo.jpg"
                alt="烟华。" />
            
              <p class="site-author-name" itemprop="name">烟华。</p>
              <p class="site-description motion-element" itemprop="description">我的偶像万丈光芒，我不能一身戾气</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wenxn" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">烟华。</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
